import java.io.*;

public class ASTAritmetica extends ASTExpresion {
	
    public ASTAritmetica(String v, ASTExpresion l, ASTExpresion r) {
	super(v, l, r);
    }

    public void update() {

	Tipo lstate = left.getState();

	if(right!=null) {

      
	    Tipo rstate = right.getState();
      
	    state = lstate.aritmetica(rstate);

            if(state.equals(new Basico(2))){

		if(lstate.equals(new Basico(1)))
		    left = new ASTCast(left,new Basico(2));

		if(rstate.equals(new Basico(1)))
		    right = new ASTCast(right,new Basico(2));

            }

	}
	else 
	    state = lstate.aritmetica();

    }
  
    public String printTree() {	
	String m = new String(value + "( " + left.printTree() + ", " + right.printTree() + " )");
	return m;
    }

    public void generateCode(Writer fd, int nextReg, String si, String no) throws IOException {	
	try {
	    int basicType = ((Basico)state).getNBasico();
	    switch (basicType) {
	    case 1:
		if (value.compareTo("+") == 0) {
		    left.generateCode(fd, nextReg, si, no);		    
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);
		    fd.write("add " + AssemblerInfo.getNombresRegAtPos(nextReg) + ", " + AssemblerInfo.getNombresRegAtPos(nextReg + 1) + "\n");		
		    AssemblerInfo.restoreReg(fd, nextReg + 1);
		}	 
		else if (value.compareTo("-") == 0) {

		    left.generateCode(fd, nextReg, si, no);
		    if (right == null) {
		    
			fd.write("neg " + AssemblerInfo.getNombresRegAtPos(nextReg) + "\n");

		    }
		    else {

			AssemblerInfo.saveReg(fd, nextReg + 1);
			right.generateCode(fd, nextReg + 1, si, no);
			fd.write("sub " + AssemblerInfo.getNombresRegAtPos(nextReg) + ", " + AssemblerInfo.getNombresRegAtPos(nextReg + 1) + "\n");
			AssemblerInfo.restoreReg(fd, nextReg + 1); 

		    }
		}
		else if (value.compareTo("*") == 0) {

		    left.generateCode(fd, nextReg, si, no);
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);
		    fd.write("imul " + AssemblerInfo.getNombresRegAtPos(nextReg) + ", " + AssemblerInfo.getNombresRegAtPos(nextReg + 1) + "\n");
		    AssemblerInfo.restoreReg(fd, nextReg + 1);

		}
		else if (value.compareTo("/") == 0){

		    left.generateCode(fd, nextReg, si, no);
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);

                    if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rax"){
			fd.write("push rdx\n");
                    }
                    else if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rdx"){
			fd.write("push rax\n");
                    }
                    else{
			fd.write("push rdx\n");
			fd.write("push rax\n");
                    }

                    fd.write("mov rdx, 0\n");
                    fd.write("mov rax, " + AssemblerInfo.getNombresRegAtPos(nextReg) + "\n");

		    fd.write("idiv " + AssemblerInfo.getNombresRegAtPos(nextReg + 1) + "\n");

                    fd.write("mov "+ AssemblerInfo.getNombresRegAtPos(nextReg) +", rax \n");


                    if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rax"){
			fd.write("pop rdx\n");
                    }
                    else if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rdx"){
			fd.write("pop rax\n");
                    }
                    else{
			fd.write("pop rax\n");
			fd.write("pop rdx\n");
                    }
            AssemblerInfo.restoreReg(fd, nextReg + 1);

		    /*

		      Cambie tu codigo gaby porsia te lo dejo aca comentado. Probe el mio y sirve, de todos modos nunca se sabe.

		      left.generateCode(fd, nextReg, si, no);
		      AssemblerInfo.saveReg(fd, nextReg + 1);
		      right.generateCode(fd, nextReg + 1, si, no);
		    
		      //Salvo rax y rdx porque se usan como operandos en idiv
		      fd.write("push rax\n");
		      fd.write("push rdx\n");

		      //Cargo a la pila los valores que voy a dividir, esto es en caso de que nextReg y nextReg + 1 caigan casualmente en rax o rdx
		      fd.write("push " + AssemblerInfo.getNombresRegAtPos(nextReg + 1) + "\n");
		      fd.write("push " + AssemblerInfo.getNombresRegAtPos(nextReg) + "\n");
		      fd.write("pop eax\n");
		      fd.write("mov edx, 0\n");
		      fd.write("idiv [rsp]\n");

		    

		      AssemblerInfo.restoreReg(fd, nextReg + 1);
		    */
		}
		else if (value.compareTo("%") == 0) {

		    left.generateCode(fd, nextReg, si, no);
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);

                    if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rax"){
			fd.write("push rdx\n");
                    }
                    else if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rdx"){
			fd.write("push rax\n");
                    }
                    else{
			fd.write("push rdx\n");
			fd.write("push rax\n");
                    }

                    fd.write("mov rdx, 0\n");
                    fd.write("mov rax, " + AssemblerInfo.getNombresRegAtPos(nextReg) + "\n");

		    fd.write("idiv " + AssemblerInfo.getNombresRegAtPos(nextReg + 1) + "\n");

                    fd.write("mov "+ AssemblerInfo.getNombresRegAtPos(nextReg) +", rdx \n");


                    if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rax"){
			fd.write("pop rdx\n");
                    }
                    else if( AssemblerInfo.getNombresRegAtPos(nextReg) == "rdx"){
			fd.write("pop rax\n");
                    }
                    else{
			fd.write("pop rax\n");
			fd.write("pop rdx\n");
                    }
					
		    AssemblerInfo.restoreReg(fd, nextReg + 1);

		}

		break;

	    case 2:
		String reg = AssemblerInfo.getNombresRegAtPos(nextReg);	
		String reg1 = AssemblerInfo.getNombresRegAtPos(nextReg+1);	

		if (value.compareTo("+") == 0) {
		
		    left.generateCode(fd, nextReg, si, no);		    
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);
			
		    fd.write("push "+reg+"\n");
		    fd.write("fbld qword [rsp + 4]\n");
			
			fd.write("push "+reg1+"\n");
		    fd.write("fadd qword [rsp + 4]\n");
			
			fd.write("fbst qword [rsp + 8]\n");
		    
		    fd.write("pop " + reg1 + "\n");
		    fd.write("pop " + reg + "\n");
		    
		    AssemblerInfo.restoreReg(fd, nextReg + 1);
		}	 
		else if (value.compareTo("-") == 0) {
		
		    left.generateCode(fd, nextReg, si, no);		    
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);
			
		    fd.write("push "+reg+"\n");
		    fd.write("fbld qword [rsp + 4]\n");
			
			fd.write("push "+reg1+"\n");
		    fd.write("fsub qword [rsp + 4]\n");
			
			fd.write("fbst qword [rsp + 8]\n");
		    
		    fd.write("pop " + reg1 + "\n");
		    fd.write("pop " + reg + "\n");
			
			AssemblerInfo.restoreReg(fd, nextReg + 1);
		    
		    }
		}
		else if (value.compareTo("*") == 0) {
		
		    left.generateCode(fd, nextReg, si, no);		    
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);
			
		    fd.write("push "+reg+"\n");
		    fd.write("fbld qword [rsp + 4]\n");
			
			fd.write("push "+reg1+"\n");
		    fd.write("fmul qword [rsp + 4]\n");
			
			fd.write("fbst qword [rsp + 8]\n");
		    
		    fd.write("pop " + reg1 + "\n");
		    fd.write("pop " + reg + "\n");
		}
		else if ((value.compareTo("/") == 0)) {
		
		    left.generateCode(fd, nextReg, si, no);		    
		    AssemblerInfo.saveReg(fd, nextReg + 1);
		    right.generateCode(fd, nextReg + 1, si, no);
			
		    fd.write("push "+reg+"\n");
		    fd.write("fbld qword [rsp + 4]\n");
			
			fd.write("push "+reg1+"\n");
		    fd.write("fdiv qword [rsp + 4]\n");
			
			fd.write("fbst qword [rsp + 8]\n");
		    
		    fd.write("pop " + reg1 + "\n");
		    fd.write("pop " + reg + "\n");
		}
		else if (value.compareTo("%") == 0){
		    System.out.println("Codigo del mod");
		break;
	    }	    
    	}
    	catch (Exception e) {
    	    System.out.println("Error escribiendo en archivo de salida\n");
    	}
    }
}
